{"version":3,"sources":["../src/utils/utils.ts","../src/lib/api-error.ts","../src/lib/fetcher.ts"],"sourcesContent":["type HTTPMethod = \"PUT\" | \"POST\" | \"PATCH\" | \"DELETE\" | \"GET\";\n\nexport function canSendBody(method: HTTPMethod) {\n  if (!method) {\n    throw new Error(\"No method provided.\");\n  }\n\n  if (method === \"PUT\" || method === \"POST\" || method === \"PATCH\") {\n    return true;\n  }\n\n  return false;\n}\n\nexport function parseUrl(url: string, baseURL: string) {\n  return url.startsWith(\"http\") ? url : baseURL + url;\n}\n","export type ApiErrorT = {\n  message: string;\n  statusCode?: number;\n  toastMessage?: string;\n  additionalMessage?: string;\n};\n\nexport class ApiError extends Error {\n  statusCode?: number;\n  toastMessage?: string;\n  additionalMessage?: string;\n\n  constructor(data: ApiErrorT) {\n    super(data.message);\n    this.message = data.message;\n    this.statusCode = data.statusCode;\n    this.toastMessage = data.toastMessage;\n    this.additionalMessage = data.additionalMessage;\n  }\n}\n","import { z } from \"zod\";\nimport { canSendBody, parseUrl } from \"../utils/utils.js\";\nimport { ApiError } from \"./api-error.js\";\n\ntype ResponseType = \"json\" | \"text\" | \"arrayBuffer\";\ntype HttpMethod = \"GET\" | \"POST\" | \"DELETE\" | \"PUT\" | \"PATCH\";\ntype Body = FormData | Record<string, unknown>;\n\nexport type FetcherProperties<\n  R extends ResponseType | undefined = \"json\",\n  M extends HttpMethod = \"GET\",\n  S extends z.ZodTypeAny = z.ZodTypeAny\n> = {\n  responseType?: R;\n  method: M;\n  url: string;\n  body?: M extends \"POST\"\n    ? Body\n    : M extends \"PUT\"\n    ? Body\n    : M extends \"PATCH\"\n    ? Body\n    : never;\n  schema?: R extends \"arrayBuffer\" ? never : S;\n  throwOnError?: boolean;\n  signal?: AbortSignal;\n  headers?: Record<string, string>;\n};\n\ntype ReturnType<R extends ResponseType | undefined, S extends z.ZodTypeAny> =\n  | (R extends \"arrayBuffer\"\n      ? ArrayBuffer\n      : R extends \"text\"\n      ? S extends undefined\n        ? string\n        : z.infer<S>\n      : S extends undefined\n      ? Record<string, unknown>\n      : z.infer<S>)\n  | never\n  | null;\n\nexport type CreateFetcherProperties = {\n  baseURL?: string;\n  apiErrorSchema?: z.ZodSchema;\n};\n\ntype FetcherFunction = <\n  R extends ResponseType | undefined = \"json\",\n  M extends HttpMethod = \"GET\",\n  S extends z.ZodTypeAny = z.ZodTypeAny\n>(\n  fetcherOptions: FetcherProperties<R, M, S>\n) => Promise<ReturnType<R, S>>;\n\nconst fetcher = async <\n  R extends ResponseType | undefined = \"json\",\n  M extends HttpMethod = \"GET\",\n  S extends z.ZodTypeAny = z.ZodTypeAny\n>({\n  body,\n  method,\n  responseType = \"json\",\n  schema,\n  url,\n  throwOnError = false,\n  headers,\n  signal,\n  apiErrorSchema,\n  baseURL = \"\",\n}: FetcherProperties<R, M, S> & {\n  baseURL?: string;\n  apiErrorSchema?: z.ZodSchema;\n}): Promise<ReturnType<R, S>> => {\n  try {\n    const transformedBody =\n      method === \"POST\"\n        ? body\n        : method === \"PUT\"\n        ? body\n        : method === \"PATCH\"\n        ? body\n        : null;\n\n    const fetchHeaders = new Headers();\n\n    const isMultipartRequest = transformedBody instanceof FormData;\n\n    if (!isMultipartRequest) {\n      fetchHeaders.append(\"Content-Type\", \"application/json\");\n    }\n\n    if (headers) {\n      Object.entries(headers).forEach(([key, value]) => {\n        fetchHeaders.append(key, value);\n      });\n    }\n\n    const response = await fetch(parseUrl(url, baseURL), {\n      body: canSendBody(method)\n        ? transformedBody instanceof FormData\n          ? transformedBody\n          : JSON.stringify(transformedBody)\n        : undefined,\n      credentials: \"include\",\n      signal: signal,\n      headers: fetchHeaders,\n      method: method,\n    });\n\n    if (!response.ok) {\n      const responseJson = await response.json();\n\n      if (apiErrorSchema) {\n        const parsedResponse = apiErrorSchema.safeParse(responseJson);\n        if (!parsedResponse.success) {\n          throw new ApiError({\n            statusCode: response.status,\n            message: \"error parsing failed\",\n          });\n        }\n\n        if (parsedResponse.data.toastMessage) {\n          throw new ApiError({\n            message: \"request failed\",\n            statusCode: response.status,\n            toastMessage: parsedResponse.data.toastMessage,\n          });\n        }\n\n        if (parsedResponse.data.message) {\n          throw new ApiError({\n            statusCode: response.status,\n            message: parsedResponse.data.message,\n          });\n        }\n      }\n\n      throw new ApiError({\n        statusCode: response.status,\n        message: \"request failed\",\n      });\n    }\n\n    const transformedData =\n      responseType === \"arrayBuffer\"\n        ? await response.arrayBuffer()\n        : responseType === \"text\"\n        ? await response.text()\n        : responseType === \"json\"\n        ? await response.json()\n        : await response.json();\n\n    if (!schema) {\n      return transformedData as ReturnType<R, S>;\n    }\n\n    const parsed = schema.safeParse(transformedData);\n\n    if (!parsed.success) {\n      throw new ApiError({\n        statusCode: response.status,\n        message: \"parsing failed\",\n      });\n    }\n\n    return parsed.data;\n  } catch (error) {\n    if (throwOnError) {\n      throw error;\n    }\n\n    return null;\n  }\n};\n\nexport const createFetcherInstance = ({\n  baseURL = \"\",\n  apiErrorSchema,\n}: CreateFetcherProperties): FetcherFunction => {\n  const fetcherInstance = fetcher.bind({\n    baseURL,\n    apiErrorSchema,\n  });\n\n  return fetcherInstance;\n};\n"],"mappings":"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","names":[]}